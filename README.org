#+TODO: TODO(t) STARTED(s@/!) | DONE(d!) CANCELED(c@)

Incremental redo of [[https://github.com/iani/tiny-sc][tiny-sc]].

Started on [2016-01-28 Thu 00:09]

* Roadmap

** DONE Make an object listen to notifications from another object
CLOSED: [2016-01-28 Thu 07:42]

Notification class.

** DONE Real Server Watcher, that tells when system resumes from sleep
CLOSED: [2016-01-28 Thu 07:42]

** Notify an object when a synth starts / ends

Methods Node:onStart, Node:onEnd.

** Hold a node, monitor if it runs, replace with other node on request, notify when it starts and stops running

Class =SimpleNodePlayer=

*** DONE Do not notify end when a new synth is started to replace a previous one
CLOSED: [2016-01-28 Thu 10:39]

Done in class SimpleNodePlayer.

#+BEGIN_SRC sclang
	addNode { | argNode |
		NodeWatcher.register(argNode);
		//  Release previous node if playing,
		//	but prevent that node from triggering a stopped notification when it ends.
		if (this.isPlaying) {
			node.releaseDependants; // do not notify when you end: next node is on the way
			this.prStop;
			argNode addDependant: { | changer, message |
				switch (message,
					// do not notify when started
					// \n_go, { this.changed(\started) },
					\n_end, {
						node = nil;
						this.changed(\stopped);					
					}
				);
			}
		}{
			argNode addDependant: { | changer, message |
				switch (message,
					\n_go, { this.changed(\started) },
					\n_end, {
						node = nil;
						this.changed(\stopped);					
					}
				);
			}
		};
		node = argNode;
	}
#+END_SRC

*** DONE Examples with GUI buttons to start/stop a synth
CLOSED: [2016-01-28 Thu 10:39]

See file 

** STARTED Store the source for starting a node
:LOGBOOK:  
- State "STARTED"    from ""           [2016-01-28 Thu 12:37] \\
  includes inputs and outputs
:END:      

*** NodePlayer

*** FunctionNodeSource

Stores a Function that is the source for creating Synths.  It substitutes ={ }.play= by a mechanism that caches the SynthDef created from the function, so that any new Synths from the same Function can be created by =Synth("defName")=.  This is much more efficient than compiling the SynthDef from the Function and sending it to the Server each time that a new Synth is created. 

Behavior: 

**** message =play=

When receiving the message =play=, the FunctionNodeSource creates a Synth and returns it immediately.  If the SynthDef from the Function stored in the FunctionNodeSource is already loaded in the server, then the Synth is created in the usual manner, with the =Synth("defName")=.  If however the Function is not yet loaded, the Synth is created with =Synth.basicNew= and the actual Synth instance on the scserver is created as soon as the SynthDef is loaded.

To make the algorithm of =play= faster, use a flag to check if the SynthDef is loaded (instead of performing a method from symbol each time): 

#+BEGIN_SRC sclang
  if (is_loaded) {
      player.addNode(Synth(defName, *args));
  }{
      ^this.perform(loadAndPlayMethod, args);
  }
#+END_SRC

=loadAndPlayMethod= is one of the following: 

***** sendDef2Server



***** waitForServer2Load 

**** message =source_=

1. Set the 


** STARTED 
:LOGBOOK:  
- State "STARTED"    from "TODO"       [2016-03-17 Thu 12:33] \\
  started
:END:      

** STARTED Auto-config of Synth linking
:LOGBOOK:  
- State "STARTED"    from ""           [2016-01-28 Thu 12:39] \\
  can be done in NodeSource.
:END:      

Prefer to keep code for managing groups, busses in separate class: Rhizome.

*** STARTED Rhizome class
:LOGBOOK:  
- State "STARTED"    from ""           [2016-01-28 Thu 12:48] \\
  Start with all NodeSource instances that have no inputs.
:END:      


** Unique objects - created only if not found under a key


