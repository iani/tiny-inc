#+TODO: TODO(t) STARTED(s@/!) | DONE(d!) CANCELED(c@)

Incremental redo of [[https://github.com/iani/tiny-sc][tiny-sc]].

Started on [2016-01-28 Thu 00:09]

* Roadmap

** DONE Make an object listen to notifications from another object
CLOSED: [2016-01-28 Thu 07:42]

Notification class.

** DONE Real Server Watcher, that tells when system resumes from sleep
CLOSED: [2016-01-28 Thu 07:42]

** DONE Notify an object when a synth starts / ends
CLOSED: [2016-03-20 Sun 18:58]
:LOGBOOK:  
- State "DONE"       from ""           [2016-03-20 Sun 18:58]
:END:      

Methods Node:onStart, Node:onEnd.

** DONE Hold a node, monitor if it runs, replace with other node on request, notify when it starts and stops running
CLOSED: [2016-03-20 Sun 18:58]
:LOGBOOK:  
- State "DONE"       from ""           [2016-03-20 Sun 18:58]
:END:      

Class =SimpleNodePlayer=

*** DONE Do not notify end when a new synth is started to replace a previous one
CLOSED: [2016-01-28 Thu 10:39]

Done in class SimpleNodePlayer.

#+BEGIN_SRC sclang
	addNode { | argNode |
		NodeWatcher.register(argNode);
		//  Release previous node if playing,
		//	but prevent that node from triggering a stopped notification when it ends.
		if (this.isPlaying) {
			node.releaseDependants; // do not notify when you end: next node is on the way
			this.prStop;
			argNode addDependant: { | changer, message |
				switch (message,
					// do not notify when started
					// \n_go, { this.changed(\started) },
					\n_end, {
						node = nil;
						this.changed(\stopped);					
					}
				);
			}
		}{
			argNode addDependant: { | changer, message |
				switch (message,
					\n_go, { this.changed(\started) },
					\n_end, {
						node = nil;
						this.changed(\stopped);					
					}
				);
			}
		};
		node = argNode;
	}
#+END_SRC

*** DONE Examples with GUI buttons to start/stop a synth
CLOSED: [2016-01-28 Thu 10:39]

See file 

** DONE Store the source for starting a node
CLOSED: [2016-03-20 Sun 18:57]
:LOGBOOK:  
- State "DONE"       from "STARTED"    [2016-03-20 Sun 18:57]
- State "STARTED"    from ""           [2016-01-28 Thu 12:37] \\
  includes inputs and outputs
:END:      

*** NodePlayer

*** FunctionNodeSource

Stores a Function that is the source for creating Synths.  It substitutes ={ }.play= by a mechanism that caches the SynthDef created from the function, so that any new Synths from the same Function can be created by =Synth("defName")=.  This is much more efficient than compiling the SynthDef from the Function and sending it to the Server each time that a new Synth is created. 

Behavior: 

**** message =play=

When receiving the message =play=, the FunctionNodeSource creates a Synth and returns it immediately.  If the SynthDef from the Function stored in the FunctionNodeSource is already loaded in the server, then the Synth is created in the usual manner, with the =Synth("defName")=.  If however the Function is not yet loaded, the Synth is created with =Synth.basicNew= and the actual Synth instance on the scserver is created as soon as the SynthDef is loaded.

When a FunctionNodeSource is created, it adds the given Function - or a default - as SynthDef, and sends it to the Server.

Upon sending a SynthDef to the server, the FunctionNodeSource sets its waiting_for_def flag to true.

The algorithm for the method =play= is as follows: 

#+BEGIN_SRC sclang
  if (waiting_for_def) {
      ^node ?? {
          node = Synth.basicNew(defName, server);
      }
  }{
      ^Synth(defName, *args);
  }
#+END_SRC

=loadAndPlayMethod= is one of the following: 

***** sendDef2Server



***** waitForServer2Load 

**** message =source_=

1. Set the

**** tests
:PROPERTIES:
:DATE:     <2016-03-19 Sat 09:56>
:END:

#+BEGIN_SRC sclang
  f = FuncNodeSource.new;
  f.play;
#+END_SRC

** STARTED operator syntax
:LOGBOOK:  
- State "STARTED"    from "TODO"       [2016-03-17 Thu 12:33] \\
  started
:END:      

: { } +> \symbol
: { } *> \symbol

** STARTED Auto-config of Synth linking
:LOGBOOK:  
- State "STARTED"    from ""           [2016-01-28 Thu 12:39] \\
  can be done in NodeSource.
:END:      

Prefer to keep code for managing groups, busses in separate class: Rhizome.

*** STARTED Rhizome class
:LOGBOOK:  
- State "STARTED"    from ""           [2016-01-28 Thu 12:48] \\
  Start with all NodeSource instances that have no inputs.
:END:      


** Unique objects - created only if not found under a key


