#+TODO: TODO(t) STARTED(s@/!) | DONE(d!) CANCELED(c@)

Incremental redo of [[https://github.com/iani/tiny-sc][tiny-sc]].

Started on [2016-01-28 Thu 00:09]

* Roadmap

** DONE Make an object listen to notifications from another object
CLOSED: [2016-01-28 Thu 07:42]

Notification class.

** DONE Real Server Watcher, that tells when system resumes from sleep
CLOSED: [2016-01-28 Thu 07:42]

** DONE Notify an object when a synth starts / ends
CLOSED: [2016-03-20 Sun 18:58]
:LOGBOOK:  
- State "DONE"       from ""           [2016-03-20 Sun 18:58]
:END:      

Methods Node:onStart, Node:onEnd.

** DONE Hold a node, monitor if it runs, replace with other node on request, notify when it starts and stops running
CLOSED: [2016-03-20 Sun 18:58]
:LOGBOOK:  
- State "DONE"       from ""           [2016-03-20 Sun 18:58]
:END:      

Class =SimpleSynthPlayer=

*** DONE Do not notify end when a new synth is started to replace a previous one
CLOSED: [2016-01-28 Thu 10:39]

Done in class SimpleSynthPlayer.

#+BEGIN_SRC sclang
	addNode { | argNode |
		NodeWatcher.register(argNode);
		//  Release previous node if playing,
		//	but prevent that node from triggering a stopped notification when it ends.
		if (this.isPlaying) {
			node.releaseDependants; // do not notify when you end: next node is on the way
			this.prStop;
			argNode addDependant: { | changer, message |
				switch (message,
					// do not notify when started
					// \n_go, { this.changed(\started) },
					\n_end, {
						node = nil;
						this.changed(\stopped);					
					}
				);
			}
		}{
			argNode addDependant: { | changer, message |
				switch (message,
					\n_go, { this.changed(\started) },
					\n_end, {
						node = nil;
						this.changed(\stopped);					
					}
				);
			}
		};
		node = argNode;
	}
#+END_SRC

*** DONE Examples with GUI buttons to start/stop a synth
CLOSED: [2016-01-28 Thu 10:39]

See file 

** DONE Store the source for starting a node
CLOSED: [2016-03-20 Sun 18:57]
:LOGBOOK:  
- State "DONE"       from "STARTED"    [2016-03-20 Sun 18:57]
- State "STARTED"    from ""           [2016-01-28 Thu 12:37] \\
  includes inputs and outputs
:END:      

*** SynthPlayer

*** FunctionSynthSource

Stores a Function that is the source for creating Synths.  It substitutes ={ }.play= by a mechanism that caches the SynthDef created from the function, so that any new Synths from the same Function can be created by =Synth("defName")=.  This is much more efficient than compiling the SynthDef from the Function and sending it to the Server each time that a new Synth is created. 

Behavior: 

**** message =play=

When receiving the message =play=, the FunctionSynthSource creates a Synth and returns it immediately.  If the SynthDef from the Function stored in the FunctionSynthSource is already loaded in the server, then the Synth is created in the usual manner, with the =Synth("defName")=.  If however the Function is not yet loaded, the Synth is created with =Synth.basicNew= and the actual Synth instance on the scserver is created as soon as the SynthDef is loaded.

When a FunctionSynthSource is created, it adds the given Function - or a default - as SynthDef, and sends it to the Server.

Upon sending a SynthDef to the server, the FunctionSynthSource sets its waiting_for_def flag to true.

The algorithm for the method =play= is as follows: 

#+BEGIN_SRC sclang
  if (waiting_for_def) {
      ^node ?? {
          node = Synth.basicNew(defName, server);
      }
  }{
      ^Synth(defName, *args);
  }
#+END_SRC

=loadAndPlayMethod= is one of the following: 

***** sendDef2Server



***** waitForServer2Load 

**** message =source_=

1. Set the

**** tests
:PROPERTIES:
:DATE:     <2016-03-19 Sat 09:56>
:END:

#+BEGIN_SRC sclang
  f = FuncNodeSource.new;
  f.play;
#+END_SRC

** STARTED operator syntax
:LOGBOOK:  
- State "STARTED"    from "TODO"       [2016-03-17 Thu 12:33] \\
  started
:END:      

Play function into SynthPlayer - in LinkedNode: 
: { } +> \symbol 

Play named and loaded SynthDef into SynthPlayer - in LinkedNode: 
: \default +> \symbol

Play Event into TaskPlayer - in LinkedNode:
: ( ) +> \symbol

Use =++>= to set the source of the LinkedNode without starting it. 

** STARTED Designing TaskPlayer
:LOGBOOK:  
- State "STARTED"    from "TODO"       [2016-03-21 Mon 17:20] \\
  started ...
:END:      
:PROPERTIES:
:DATE:     <2016-03-21 Mon 17:20>
:END:

*** Approach 1: Use the same archtecture and approach as for SynthPlayer, involving a TaskSource.

** Unique objects - created only if not found under a key

** STARTED Synth and Task Bus I/O linking mechanism
:LOGBOOK:  
- State "STARTED"    from "TODO"       [2016-03-22 Tue 23:08] \\
  basic concept and syntax
:END:      
:PROPERTIES:
:DATE:     <2016-03-22 Tue 23:08>
:END:

#+BEGIN_SRC sclang
\writer @> \reader; // move output of writer to input of reader
\writer <@ \reader; // move input of reader to output of writer
// operator specifies output, adverb specifies input:
\writer@\out1 @>.in2 \reader; // specify output/input params out1 and in2
#+END_SRC

=\writer= and =\reader= are unique group/rank and input/output bus holders accessible through their symbols. They can store a SynthPlayer or a TaskPlayer - interchangeably. Class: =LinkedNode=

Structure of LinkedNode: 

#+BEGIN_SRC sclang
  LinkedNode {
      var <server;
      var <rank = 0; // smaller numbers mean earlier synth order
      var <group;  // the actual group. Used as target for player.
      var <inputs; // Dictionary of Inputs (param: input, param2: input)
      var <outputs; // Dictionary of Outputs
      var <player; // SynthPlayer, TaskPlayer, or similar/compatible object

      getGroup {
          if (inputs.isNil and: { outputs.isNil }) {
              rank = 0
          }{
              rank = this.allWriters.collect(_.rank).maxItem + 1;
              this.moveToGroup;
          };
          
      }

      moveToGroup {
          this.readers do: _.moveAfter(rank);
          this.setGroup;
      }

      moveAfter { | argRank |
          if (rank <= argRank) {
              rank = argRank + 1;
              this.moveToGroup;
          }
      }
      
      setGroup {
          group = PlayerGroup(server, rank);
          player !? { player.target = group };
      }

      getArgs {
          
      }
  }

  Input {
      var <parameter; // name of input parameter
      var <bus;
      var <readerNode; // the LinkedNode that has this input
      var <writers;   // set of Outputs that write to this input
  }

  Output {
      var <parameter; // name of input parameter
      var <bus;
      var <writerNode; // the LinkedNode that has this output
      var <readers;   // set of Inputs that read from this output
  }

  PlayerGroup {
      var <server, <groups;
      ,*new { | server, rank = 0 |
          ^Registry(this, server, { this.newCopyArgs(server, []) })
          .getGroup(rank);
      };

      getGroup { | rank |
          var root;
          root = server.rootNode;
          rank - groups.size + 1 max: 0 do: {
              groups = groups add: Group.tail(root);
          };
          ^groups[rank];
      }
  }

#+END_SRC
