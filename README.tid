<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Roadmap</a>
<ul>
<li><a href="#sec-1-1">1.1. <span class="done DONE">DONE</span> Make an object listen to notifications from another object</a></li>
<li><a href="#sec-1-2">1.2. <span class="done DONE">DONE</span> Real Server Watcher, that tells when system resumes from sleep</a></li>
<li><a href="#sec-1-3">1.3. <span class="done DONE">DONE</span> Notify an object when a synth starts / ends</a></li>
<li><a href="#sec-1-4">1.4. <span class="done DONE">DONE</span> Hold a node, monitor if it runs, replace with other node on request, notify when it starts and stops running</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. <span class="done DONE">DONE</span> Do not notify end when a new synth is started to replace a previous one</a></li>
<li><a href="#sec-1-4-2">1.4.2. <span class="done DONE">DONE</span> Examples with GUI buttons to start/stop a synth</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. <span class="done DONE">DONE</span> Store the source for starting a node</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. SynthPlayer</a></li>
<li><a href="#sec-1-5-2">1.5.2. FunctionSynthSource</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. <span class="done DONE">DONE</span> Unique objects - created only if not found under a key</a></li>
<li><a href="#sec-1-7">1.7. <span class="todo STARTED">STARTED</span> Designing TaskPlayer</a>
<ul>
<li><a href="#sec-1-7-1">1.7.1. Approach 1: Use the same archtecture and approach as for SynthPlayer, involving a TaskSource.</a></li>
</ul>
</li>
<li><a href="#sec-1-8">1.8. <span class="todo STARTED">STARTED</span> Synth and Task Bus I/O linking mechanism</a></li>
<li><a href="#sec-1-9">1.9. <span class="todo STARTED">STARTED</span> operator syntax</a>
<ul>
<li><a href="#sec-1-9-1">1.9.1. Operator overview</a></li>
<li><a href="#sec-1-9-2">1.9.2. Details</a></li>
<li><a href="#sec-1-9-3">1.9.3. for simplicity, these will not be attempted now:</a></li>
</ul>
</li>
<li><a href="#sec-1-10">1.10. <span class="todo TODO">TODO</span> Overview of Classes</a>
<ul>
<li><a href="#sec-1-10-1">1.10.1. Synth and Task playing</a></li>
<li><a href="#sec-1-10-2">1.10.2. Linking Synth I/O</a></li>
<li><a href="#sec-1-10-3">1.10.3. Utilities</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

Incremental redo of [tiny-sc](https://github.com/iani/tiny-sc).

Started on <span class="timestamp-wrapper"><span class="timestamp">[2016-01-28 Thu 00:09]</span></span>

# Roadmap<a id="sec-1" name="sec-1"></a>

## DONE Make an object listen to notifications from another object<a id="sec-1-1" name="sec-1-1"></a>

Notification class.

## DONE Real Server Watcher, that tells when system resumes from sleep<a id="sec-1-2" name="sec-1-2"></a>

## DONE Notify an object when a synth starts / ends<a id="sec-1-3" name="sec-1-3"></a>

Methods Node:onStart, Node:onEnd.

## DONE Hold a node, monitor if it runs, replace with other node on request, notify when it starts and stops running<a id="sec-1-4" name="sec-1-4"></a>

Class `SimpleSynthPlayer`

### DONE Do not notify end when a new synth is started to replace a previous one<a id="sec-1-4-1" name="sec-1-4-1"></a>

Done in class SimpleSynthPlayer.

    addNode { | argNode |
        NodeWatcher.register(argNode);
        //  Release previous node if playing,
        //  but prevent that node from triggering a stopped notification when it ends.
        if (this.isPlaying) {
            node.releaseDependants; // do not notify when you end: next node is on the way
            this.prStop;
            argNode addDependant: { | changer, message |
                switch (message,
                    // do not notify when started
                    // \n_go, { this.changed(\started) },
                    \n_end, {
                        node = nil;
                        this.changed(\stopped);                 
                    }
                );
            }
        }{
            argNode addDependant: { | changer, message |
                switch (message,
                    \n_go, { this.changed(\started) },
                    \n_end, {
                        node = nil;
                        this.changed(\stopped);                 
                    }
                );
            }
        };
        node = argNode;
    }

### DONE Examples with GUI buttons to start/stop a synth<a id="sec-1-4-2" name="sec-1-4-2"></a>

See file 

## DONE Store the source for starting a node<a id="sec-1-5" name="sec-1-5"></a>


### SynthPlayer<a id="sec-1-5-1" name="sec-1-5-1"></a>

### FunctionSynthSource<a id="sec-1-5-2" name="sec-1-5-2"></a>

Stores a Function that is the source for creating Synths.  It substitutes `{ }.play` by a mechanism that caches the SynthDef created from the function, so that any new Synths from the same Function can be created by `Synth("defName")`.  This is much more efficient than compiling the SynthDef from the Function and sending it to the Server each time that a new Synth is created. 

Behavior: 

1.  message `play`

    When receiving the message `play`, the FunctionSynthSource creates a Synth and returns it immediately.  If the SynthDef from the Function stored in the FunctionSynthSource is already loaded in the server, then the Synth is created in the usual manner, with the `Synth("defName")`.  If however the Function is not yet loaded, the Synth is created with `Synth.basicNew` and the actual Synth instance on the scserver is created as soon as the SynthDef is loaded.
    
    When a FunctionSynthSource is created, it adds the given Function - or a default - as SynthDef, and sends it to the Server.
    
    Upon sending a SynthDef to the server, the FunctionSynthSource sets its waiting\_for\_def flag to true.
    
    The algorithm for the method `play` is as follows: 
    
        if (waiting_for_def) {
            ^node ?? {
                node = Synth.basicNew(defName, server);
            }
        }{
            ^Synth(defName, *args);
        }
    
    `loadAndPlayMethod` is one of the following: 
    
    1.  sendDef2Server
    
    2.  waitForServer2Load

2.  message `source_`

    1.  Set the

3.  tests

    
        f = FuncNodeSource.new;
        f.play;

## DONE Unique objects - created only if not found under a key<a id="sec-1-6" name="sec-1-6"></a>

See `Registry` class.

## STARTED Designing TaskPlayer<a id="sec-1-7" name="sec-1-7"></a>



### Approach 1: Use the same archtecture and approach as for SynthPlayer, involving a TaskSource.<a id="sec-1-7-1" name="sec-1-7-1"></a>

## STARTED Synth and Task Bus I/O linking mechanism<a id="sec-1-8" name="sec-1-8"></a>


    \writer @> \reader; // move output of writer to input of reader
    \writer <@ \reader; // move input of reader to output of writer
    // operator specifies output, adverb specifies input:
    \writer@\out1 @>.in2 \reader; // specify output/input params out1 and in2

`\writer` and `\reader` are unique group/rank and input/output bus holders accessible through their symbols. They can store a SynthPlayer or a TaskPlayer - interchangeably. Class: `SynthLink`

Structure of SynthLink: 

    SynthLink {
        var <server;
        var <rank = 0; // smaller numbers mean earlier synth order
        var <group;  // the actual group. Used as target for player.
        var <inputs; // Dictionary of Inputs (param: input, param2: input)
        var <outputs; // Dictionary of Outputs
        var <player; // SynthPlayer, TaskPlayer, or similar/compatible object
    
        getGroup {
            if (inputs.isNil and: { outputs.isNil }) {
                rank = 0
            }{
                rank = this.allWriters.collect(_.rank).maxItem + 1;
                this.moveToGroup;
            };
    
        }
    
        moveToGroup {
            this.readers do: _.moveAfter(rank);
            this.setGroup;
        }
    
        moveAfter { | argRank |
            if (rank <= argRank) {
                rank = argRank + 1;
                this.moveToGroup;
            }
        }
    
        setGroup {
            group = PlayerGroup(server, rank);
            player !? { player.target = group };
        }
    
        getArgs {
    
        }
    }
    
    Input {
        var <parameter; // name of input parameter
        var <bus;
        var <readerNode; // the SynthLink that has this input
        var <writers;   // set of Outputs that write to this input
    }
    
    Output {
        var <parameter; // name of input parameter
        var <bus;
        var <writerNode; // the SynthLink that has this output
        var <readers;   // set of Inputs that read from this output
    }
    
    PlayerGroup {
        var <server, <groups;
        *new { | server, rank = 0 |
            ^Registry(this, server, { this.newCopyArgs(server, []) })
            .getGroup(rank);
        };
    
        getGroup { | rank |
            var root;
            root = server.rootNode;
            rank - groups.size + 1 max: 0 do: {
                groups = groups add: Group.tail(root);
            };
            ^groups[rank];
        }
    }

## STARTED operator syntax<a id="sec-1-9" name="sec-1-9"></a>


### Operator overview<a id="sec-1-9-1" name="sec-1-9-1"></a>

1.  Playing
    -   **`+>`:** Start playing something in a SynthLink.
        Note:  If the first (left) operand is an event, it adds or sets the EventPattern of an EventPlayer that is attached to the TaskPlayer as player. The default name of the player is `player`.  Another name is used if it is provided as adverb to the `+>` operator.
    -   **`+>>`:** Set the pattern of the TaskPlayer in the SynthLink, and start. Do not add any EventPlayer to the TaskPlayer.
2.  Modifying args
    For TaskPlayer, these modify the EventStream of the default EventPlayer or the player specified in the adverb to the operator.
    -   **`%>`:** Add args to event or arg-array
    -   **`!%>`:** Replace event or arg-array
3.  Modifying pattern of the TaskPlayer
    These modify the pattern and stream of the TaskPlayer, not of any EventPlayer.
    -   **`>>`:** &#x2026;
    -   **`!>>`:** &#x2026;
4.  Linking SynthLinks
    -   **`@>`:** &#x2026;
    -   **`<@`:** &#x2026;
    -   **`@`:** &#x2026;

### Details<a id="sec-1-9-2" name="sec-1-9-2"></a>

1.  `+>` : Set source of SynthLink and play.

    Play function into SynthPlayer - in SynthLink: 
    
        { } +> \symbol
    
    Play named and loaded SynthDef into SynthPlayer - in SynthLink: 
    
        \default +> \symbol
    
    Play Event into TaskPlayer - in SynthLink:
    
        ( ) +> \symbol // Plays through default EventPlayer as TaskPlayer-player
        ( ) +> \symbol // Plays through default EventPlayer as TaskPlayer-player
    
    Possibly: 
    
    -   **`number +> \symbol`:** use number as duration to start TaskPlayer in SynthLink
    -   **`pattern +> \symbol`:** use pattern as duration to start TaskPlayer in SynthLink

2.  `%>` : change args in SynthLink, and send them to player - without restarting

    () %> \symbol

### for simplicity, these will not be attempted now:<a id="sec-1-9-3" name="sec-1-9-3"></a>


-   **`++>`:** Set source of SynthLink but do not play now
-   **`%%>`:** change args in SynthLink, but do not send them to player now.

## TODO Overview of Classes<a id="sec-1-10" name="sec-1-10"></a>



### Synth and Task playing<a id="sec-1-10-1" name="sec-1-10-1"></a>

1.  Source containers for players

    1.  FunctionSynthSource
    
    2.  SynthDefSource

2.  Players

    1.  SynthPlayer
    
    2.  TaskPlayer

### Linking Synth I/O<a id="sec-1-10-2" name="sec-1-10-2"></a>

### Utilities<a id="sec-1-10-3" name="sec-1-10-3"></a>

1.  Notification

2.  ServerBootCheck

3.  onEnd, onStart

4.  Registry
