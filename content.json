{"meta":{"title":"Tiny Inc","subtitle":"Incremental redo of Tiny-sc","description":"Tiny-sc lib redone from essentials","author":"Iannis Zannos","url":"http://iani.github.io"},"pages":[],"posts":[{"title":"Initial README File","slug":"readme","date":"2017-06-01T18:00:11.000Z","updated":"2017-06-01T18:05:53.000Z","comments":true,"path":"2017/06/01/readme/","link":"","permalink":"http://iani.github.io/2017/06/01/readme/","excerpt":"","text":"Incremental redo of tiny-sc. Started on [2016-01-28 Thu 00:09] Player classes SynthPlayer PatternPlayer Operators Operators / revision from 0 version 31 May 2017 22:37 ff Step 1: +&gt; // play function as Synth in SynthPlayer&#10;Function +&#38;gt; Symbol; &#10;&#10;// play any pattern-capable object as stream in key in EventStreamPlayer&#10;Pattern +&#38;gt; Symbol; Starting implementation for EventStreamPlayer 1 Jun 2017 20:00. STARTED operator syntax - version 201603 Operator overview Playing +&gt; Start playing something in a SynthLink. Note: If the first (left) operand is an event, it adds or sets the EventPattern of an EventPlayer that is attached to the TaskPlayer as player. The default name of the player is player. Another name is used if it is provided as adverb to the +&gt; operator. +&gt;&gt; Set the pattern of the TaskPlayer in the SynthLink, and start. Do not add any EventPlayer to the TaskPlayer. Modifying args For TaskPlayer, these modify the EventStream of the default EventPlayer or the player specified in the adverb to the operator. %&gt; Add args to event or arg-array !%&gt; Replace event or arg-array Modifying pattern of the TaskPlayer These modify the pattern and stream of the TaskPlayer, not of any EventPlayer. &gt;&gt; &#x2026; !&gt;&gt; &#x2026; Linking SynthLinks @&gt; &#x2026;b・・・ &lt;@ &#x2026; @ &#x2026; @+ +@ Details +&gt; : Set source of SynthLink and play. Play function into SynthPlayer - in SynthLink: { } +&gt; \\symbol Play named and loaded SynthDef into SynthPlayer - in SynthLink: \\default +&gt; \\symbol Play Event into TaskPlayer - in SynthLink: ( ) +&gt; \\symbol // Plays through default EventPlayer as TaskPlayer-player ( ) +&gt; \\symbol // Plays through default EventPlayer as TaskPlayer-player Possibly: number +&gt; \\symbol use number as duration to start TaskPlayer in SynthLink pattern +&gt; \\symbol use pattern as duration to start TaskPlayer in SynthLink %&gt; : change args in SynthLink, and send them to player - without restarting () %&gt; \\symbol for simplicity, these will not be attempted now: ++&gt; Set source of SynthLink but do not play now %%&gt; change args in SynthLink, but do not send them to player now. Roadmap DONE Make an object listen to notifications from another object Notification class. DONE Real Server Watcher, that tells when system resumes from sleep DONE Notify an object when a synth starts / ends Methods Node:onStart, Node:onEnd. DONE Hold a node, monitor if it runs, replace with other node on request, notify when it starts and stops running Class SimpleSynthPlayer DONE Do not notify end when a new synth is started to replace a previous one Done in class SimpleSynthPlayer. addNode { | argNode |&#10;&#9;NodeWatcher.register(argNode);&#10;&#9;// Release previous node if playing,&#10;&#9;// but prevent that node from triggering a stopped notification when it ends.&#10;&#9;if (this.isPlaying) {&#10;&#9;&#9;node.releaseDependants; // do not notify when you end: next node is on the way&#10;&#9;&#9;this.prStop;&#10;&#9;&#9;argNode addDependant: { | changer, message |&#10;&#9;&#9;&#9;switch (message,&#10;&#9;&#9;&#9;&#9;// do not notify when started&#10;&#9;&#9;&#9;&#9;// \\n_go, { this.changed(\\started) },&#10;&#9;&#9;&#9;&#9;\\n_end, {&#10;&#9;&#9;&#9;&#9;&#9;node = nil;&#10;&#9;&#9;&#9;&#9;&#9;this.changed(\\stopped); &#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;);&#10;&#9;&#9;}&#10;&#9;}{&#10;&#9;&#9;argNode addDependant: { | changer, message |&#10;&#9;&#9;&#9;switch (message,&#10;&#9;&#9;&#9;&#9;\\n_go, { this.changed(\\started) },&#10;&#9;&#9;&#9;&#9;\\n_end, {&#10;&#9;&#9;&#9;&#9;&#9;node = nil;&#10;&#9;&#9;&#9;&#9;&#9;this.changed(\\stopped); &#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;);&#10;&#9;&#9;}&#10;&#9;};&#10;&#9;node = argNode;&#10;} DONE Examples with GUI buttons to start/stop a synth See file DONE Store the source for starting a node SynthPlayer FunctionSynthSource Stores a Function that is the source for creating Synths. It substitutes { }.play by a mechanism that caches the SynthDef created from the function, so that any new Synths from the same Function can be created by Synth(\"defName\"). This is much more efficient than compiling the SynthDef from the Function and sending it to the Server each time that a new Synth is created. Behavior: message play When receiving the message play, the FunctionSynthSource creates a Synth and returns it immediately. If the SynthDef from the Function stored in the FunctionSynthSource is already loaded in the server, then the Synth is created in the usual manner, with the Synth(\"defName\"). If however the Function is not yet loaded, the Synth is created with Synth.basicNew and the actual Synth instance on the scserver is created as soon as the SynthDef is loaded. When a FunctionSynthSource is created, it adds the given Function - or a default - as SynthDef, and sends it to the Server. Upon sending a SynthDef to the server, the FunctionSynthSource sets its waitingfordef flag to true. The algorithm for the method play is as follows: if (waiting_for_def) {&#10; ^node ?? {&#10;&#9;node = Synth.basicNew(defName, server);&#10; }&#10;}{&#10; ^Synth(defName, *args);&#10;} loadAndPlayMethod is one of the following: sendDef2Server waitForServer2Load message source_ Set the tests f = FuncNodeSource.new;&#10;f.play; DONE Unique objects - created only if not found under a key See Registry class. STARTED Designing TaskPlayer Approach 1: Use the same archtecture and approach as for SynthPlayer, involving a TaskSource. STARTED Synth and Task Bus I/O linking mechanism \\writer @&#38;gt; \\reader; // move output of writer to input of reader&#10;\\writer &#38;lt;@ \\reader; // move input of reader to output of writer&#10;// operator specifies output, adverb specifies input:&#10;\\writer@\\out1 @&#38;gt;.in2 \\reader; // specify output/input params out1 and in2 Possible extra operators: \\writer @+ \\reader; // branch output of writer to reader with i/o copy synth&#10;\\writer +@ \\reader; // branch to input of reader with i/o copy synth \\writer and \\reader are unique group/rank and input/output bus holders accessible through their symbols. They can store a SynthPlayer or a TaskPlayer - interchangeably. Class: SynthLink Structure of SynthLink: SynthLink {&#10; var &#38;lt;server;&#10; var &#38;lt;rank = 0; // smaller numbers mean earlier synth order&#10; var &#38;lt;group; // the actual group. Used as target for player.&#10; var &#38;lt;inputs; // Dictionary of Inputs (param: input, param2: input)&#10; var &#38;lt;outputs; // Dictionary of Outputs&#10; var &#38;lt;player; // SynthPlayer, TaskPlayer, or similar/compatible object&#10;&#10; getGroup {&#10;&#9;if (inputs.isNil and: { outputs.isNil }) {&#10;&#9; rank = 0&#10;&#9;}{&#10;&#9; rank = this.allWriters.collect(_.rank).maxItem + 1;&#10;&#9; this.moveToGroup;&#10;&#9;};&#10;&#10; }&#10;&#10; moveToGroup {&#10;&#9;this.readers do: _.moveAfter(rank);&#10;&#9;this.setGroup;&#10; }&#10;&#10; moveAfter { | argRank |&#10;&#9;if (rank &#38;lt;= argRank) {&#10;&#9; rank = argRank + 1;&#10;&#9; this.moveToGroup;&#10;&#9;}&#10; }&#10;&#10; setGroup {&#10;&#9;group = PlayerGroup(server, rank);&#10;&#9;player !? { player.target = group };&#10; }&#10;&#10; getArgs {&#10;&#10; }&#10;}&#10;&#10;Input {&#10; var &#38;lt;parameter; // name of input parameter&#10; var &#38;lt;bus;&#10; var &#38;lt;readerNode; // the SynthLink that has this input&#10; var &#38;lt;writers; // set of Outputs that write to this input&#10;}&#10;&#10;Output {&#10; var &#38;lt;parameter; // name of input parameter&#10; var &#38;lt;bus;&#10; var &#38;lt;writerNode; // the SynthLink that has this output&#10; var &#38;lt;readers; // set of Inputs that read from this output&#10;}&#10;&#10;PlayerGroup {&#10; var &#38;lt;server, &#38;lt;groups;&#10; *new { | server, rank = 0 |&#10;&#9;^Registry(this, server, { this.newCopyArgs(server, []) })&#10;&#9;.getGroup(rank);&#10; };&#10;&#10; getGroup { | rank |&#10;&#9;var root;&#10;&#9;root = server.rootNode;&#10;&#9;rank - groups.size + 1 max: 0 do: {&#10;&#9; groups = groups add: Group.tail(root);&#10;&#9;};&#10;&#9;^groups[rank];&#10; }&#10;} STARTED start and restart methods Only in SynthLink, not in SynthPlayer or TaskPlayer start if not playing stop previous process and start again TODO Overview of Classes Synth and Task playing Source containers for playersFunctionSynthSource SynthDefSource PlayersSynthPlayer TaskPlayer Linking Synth I/O Utilities Notification ServerBootCheck onEnd, onStart Registry STARTED SynthLink addEventAsTaskPlayerSource notes To watch: player pattern should copy STARTED SynthLink +&gt;&gt; notes To watch: How exactly is the EventPlayer produced, and where, in the chain of method calls, when the TaskPatternPlayer is produced. TODO UGen + SynthDef Shortcuts Author: Ioannis Zannos Created: 2017-06-01 Thu 21:05 Emacs 25.1.1 (Org mode 8.2.10) Validate","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"http://iani.github.io/categories/uncategorized/"}],"tags":[{"name":"readme","slug":"readme","permalink":"http://iani.github.io/tags/readme/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-06-01T17:11:07.000Z","updated":"2017-06-01T17:11:07.000Z","comments":true,"path":"2017/06/01/hello-world/","link":"","permalink":"http://iani.github.io/2017/06/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}